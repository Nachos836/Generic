using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ZLinq;

namespace CustomAttributesEditorGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class ButtonDrawerGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "InspectorAttributes.ButtonAttribute";

    private static readonly System.Version Version = new(1, 0, 0);

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidateMethods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (context, _) => GetIfButton(context))
            .Where(static symbol => symbol is not null);

        var grouped = candidateMethods.Collect()
            .Select(static (methods, _) => methods
                .GroupBy(static method => method!.ContainingType, SymbolEqualityComparer.Default));

        context.RegisterSourceOutput(grouped, GenerateDrawers);

        return;

        static IMethodSymbol? GetIfButton(GeneratorSyntaxContext context)
        {
            var method = (MethodDeclarationSyntax) context.Node;
            if (context.SemanticModel.GetDeclaredSymbol(method) is not { } symbol) return null;

            return symbol.GetAttributes()
                .AsValueEnumerable()
                .Any(static candidate => candidate.AttributeClass?.ToDisplayString() == AttributeFullName)
                    ? symbol
                    : null;
        }
    }

    private static void GenerateDrawers(SourceProductionContext productionContext, IEnumerable<IGrouping<ISymbol?, IMethodSymbol?>> groups)
    {
        foreach (var group in groups)
        {
            if (group.Key is not INamedTypeSymbol container) continue;

            var hasPartialDeclaration = container.DeclaringSyntaxReferences
                .Select(static syntaxReference => syntaxReference.GetSyntax())
                .OfType<ClassDeclarationSyntax>()
                .Any(static declarationSyntax => declarationSyntax.Modifiers
                    .Any(static token => token.IsKind(SyntaxKind.PartialKeyword)));

            if (hasPartialDeclaration is false)
            {
                var location = container.Locations.FirstOrDefault() ?? Location.None;
                productionContext.ReportDiagnostic(Diagnostic.Create
                (
                    Diagnostics.MissingPartialDescriptor,
                    location,
                    messageArgs: container.Name
                ));

                return;
            }

            var @namespace = SyntaxFactory
                .NamespaceDeclaration(SyntaxFactory.ParseName(container.ContainingNamespace.ToDisplayString()));

            var ownerName = container.Name.Replace("global::", "")
                .Replace('<','_')
                .Replace('>','_');
            var ownerAccessibility = container.OriginalDefinition.DeclaredAccessibility switch
            {
                Accessibility.Public => SyntaxKind.PublicKeyword,
                _ => SyntaxKind.InternalKeyword
            };
            var ownerSealed = container.OriginalDefinition.IsSealed switch
            {
                true => SyntaxKind.SealedKeyword,
                false => SyntaxKind.None
            };
            var ownerAbstract = container.OriginalDefinition.IsAbstract switch
            {
                true => SyntaxKind.AbstractKeyword,
                false => SyntaxKind.None
            };

            var ownerSourceCode = SyntaxFactory.CompilationUnit()
                .AddUsings(
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(Using.System.CodeDom.Compiler.Value)),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(Using.System.Diagnostics.Value)),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(Using.System.Diagnostics.CodeAnalysis.Value)))
                .WithLeadingTrivia(SyntaxFactory.TriviaList(
                    SyntaxFactory.Comment("// <auto-generated/>"),
                    SyntaxFactory.ElasticCarriageReturnLineFeed,
                    SyntaxFactory.LineFeed,
                    SyntaxFactory.Trivia(SyntaxFactory.IfDirectiveTrivia(SyntaxFactory.IdentifierName("UNITY_EDITOR"), isActive: true, branchTaken: true, conditionValue: true)),
                    SyntaxFactory.ElasticCarriageReturnLineFeed,
                    SyntaxFactory.LineFeed,
                    SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), isActive: true)),
                    SyntaxFactory.ElasticCarriageReturnLineFeed,
                    SyntaxFactory.LineFeed))
                .AddUsings(
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(Using.Unity.Editor.Value)),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(Using.Unity.Engine.UIElements.Value)))
                .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                    @namespace.WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(

                        SyntaxFactory.ClassDeclaration(ownerName)
                            .WithModifiers(SyntaxFactory.TokenList()
                                .AddIfPresent(SyntaxFactory.Token(ownerAccessibility))
                                .AddIfPresent(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                                .AddIfPresent(SyntaxFactory.Token(ownerSealed))
                                .AddIfPresent(SyntaxFactory.Token(ownerAbstract)))
                            .WithAttributeLists(SyntaxFactory.SingletonList(SyntaxFactory.AttributeList()
                                .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("ExcludeFromCodeCoverage")))
                                .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("DebuggerNonUserCode")))
                                .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("GeneratedCode"), SyntaxFactory.AttributeArgumentList()
                                    .WithArguments(SyntaxFactory.SeparatedList<AttributeArgumentSyntax>()
                                        .Add(SyntaxFactory.AttributeArgument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(nameof(CustomAttributesEditorGenerator)))))
                                        .Add(SyntaxFactory.AttributeArgument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(Version.ToString())))))))))
                            .WithBaseList(SyntaxFactory.BaseList(
                                SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(
                                    SyntaxFactory.SimpleBaseType(SyntaxFactory.IdentifierName(nameof(UnityEngine.MonoBehaviour))))))

                            .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                                SyntaxFactory.ClassDeclaration(ownerName + "Drawer")
                                    .WithModifiers(SyntaxFactory.TokenList()
                                        .AddIfPresent(SyntaxFactory.Token(ownerAccessibility))
                                        .AddIfPresent(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                                        .AddIfPresent(SyntaxFactory.Token(ownerSealed))
                                        .AddIfPresent(SyntaxFactory.Token(ownerAbstract)))
                                    .WithAttributeLists(SyntaxFactory.SingletonList(SyntaxFactory.AttributeList()
                                        .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("ExcludeFromCodeCoverage")))
                                        .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("DebuggerNonUserCode")))
                                        .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("GeneratedCode"), SyntaxFactory.AttributeArgumentList()
                                            .WithArguments(SyntaxFactory.SeparatedList<AttributeArgumentSyntax>()
                                                .Add(SyntaxFactory.AttributeArgument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(nameof(CustomAttributesEditorGenerator)))))
                                                .Add(SyntaxFactory.AttributeArgument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(Version.ToString())))))))))
                                    .AddAttributeLists(SyntaxFactory.AttributeList()
                                        .AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("CustomEditor"), SyntaxFactory.AttributeArgumentList()
                                            .WithArguments(SyntaxFactory.SeparatedList<AttributeArgumentSyntax>()
                                                .Add(SyntaxFactory.AttributeArgument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(container.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)))))))))
                                    .WithBaseList(SyntaxFactory.BaseList(
                                        SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(
                                            SyntaxFactory.SimpleBaseType(SyntaxFactory.IdentifierName(nameof(UnityEditor.Editor))))))
                                ))






                                // SyntaxFactory.SingletonList(
                                // SyntaxFactory.AttributeList(
                                //     SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("UnityEditor.CustomEditor"))
                                //                 .WithArgumentList(SyntaxFactory.AttributeArgumentList(
                                //                     SyntaxFactory.SingletonSeparatedList(
                                //                         SyntaxFactory.AttributeArgument(
                                //                             SyntaxFactory.TypeOfExpression(
                                //                                 SyntaxFactory.ParseTypeName(targetTypeName)
                                //                             )
                                //                         )
                                //                     )
                                //                 )
                                //             )
                                //     )
                                // )))


                        ))))
                .WithTrailingTrivia(SyntaxFactory.TriviaList()
                    .Add(SyntaxFactory.Comment("\r\n\n"))
                    .Add(SyntaxFactory.Trivia(SyntaxFactory.EndIfDirectiveTrivia(isActive: true)))
                    .Add(SyntaxFactory.CarriageReturn));

            productionContext.AddSource($"{ownerName}Drawer.g.cs", ownerSourceCode.PrettyPrint());








            var accessibility = container.OriginalDefinition.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                _ => "internal"
            };

            var buttonsCode = string.Join("\n            ", group.Select(BuildButtonCode));

            var drawerSourceCode = $$"""
            // <auto-generated/>

            #if UNITY_EDITOR

            #nullable enable

            using System.CodeDom.Compiler;
            using System.Diagnostics;
            using System.Diagnostics.CodeAnalysis;

            using UnityEditor;
            using UnityEngine.UIElements;

            {{@namespace}}
            {
                [DebuggerNonUserCode]
                [ExcludeFromCodeCoverage]
                [GeneratedCode("CustomAttributesEditorGenerator", "1.0.0")]
                {{accessibility}} sealed partial class {{ownerName}}
                {
                    [DebuggerNonUserCode]
                    [ExcludeFromCodeCoverage]
                    [GeneratedCode("CustomAttributesEditorGenerator", "1.0.0")]
                    [CustomEditor(typeof({{container.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}}))]
                    internal sealed partial class ButtonDrawer_{{ownerName}} : UnityEditor.Editor
                    {
                        public override VisualElement CreateInspectorGUI()
                        {
                            var root = new VisualElement();
                            UnityEditor.UIElements.InspectorElement.FillDefaultInspector(root, serializedObject, this);

                            WhenButtonAttributeDetected(root);

                            return root;
                        }

                        private partial void WhenButtonAttributeDetected(VisualElement root);
                    }
                }
            }

            #endif

            """;

            var whenNoButtonsSources = $$"""
            // <auto-generated/>

            #if UNITY_EDITOR

            #nullable enable

            using UnityEditor;
            using UnityEngine.UIElements;

            {{@namespace}}
            {
                {{accessibility}} sealed partial class {{ownerName}}
                {
                    internal sealed partial class ButtonDrawer_{{ownerName}}
                    {
                        private partial void WhenButtonAttributeDetected(VisualElement root)
                        {
                            var targetTyped = ({{container.ToDisplayString()}})target;
            
                            {{buttonsCode}}
                        }
                    }
                }
            }

            #endif

            """;

            productionContext.AddSource($"ButtonDrawer_{ownerName}.buttons.g.cs", whenNoButtonsSources);
        }
    }

    private static void FormerGenerateDrawers(SourceProductionContext spc, IEnumerable<IGrouping<ISymbol?, IMethodSymbol?>> groups)
    {
        foreach (var group in groups)
        {
            if (group.Key == null) continue;
            var type = group.Key;

            var @namespace = type.ContainingNamespace.IsGlobalNamespace
                ? "namespace Generated"
                : $"namespace {type.ContainingNamespace}";

            var safeName = type.Name.Replace('<','_').Replace('>','_');
            var accessibility = type.OriginalDefinition.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                _ => "internal"
            };

            var buttonsCode = string.Join("\n            ", group.Select(BuildButtonCode));

            var drawerSourceCode = $$"""
            // <auto-generated/>

            #if UNITY_EDITOR

            #nullable enable

            using System.CodeDom.Compiler;
            using System.Diagnostics;
            using System.Diagnostics.CodeAnalysis;

            using UnityEditor;
            using UnityEngine.UIElements;

            {{@namespace}}
            {
                [DebuggerNonUserCode]
                [ExcludeFromCodeCoverage]
                [GeneratedCode("CustomAttributesEditorGenerator", "1.0.0")]
                {{accessibility}} sealed partial class {{safeName}}
                {
                    [DebuggerNonUserCode]
                    [ExcludeFromCodeCoverage]
                    [GeneratedCode("CustomAttributesEditorGenerator", "1.0.0")]
                    [CustomEditor(typeof({{type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}}))]
                    internal sealed partial class ButtonDrawer_{{safeName}} : UnityEditor.Editor
                    {
                        public override VisualElement CreateInspectorGUI()
                        {
                            var root = new VisualElement();
                            UnityEditor.UIElements.InspectorElement.FillDefaultInspector(root, serializedObject, this);

                            WhenButtonAttributeDetected(root);

                            return root;
                        }

                        private partial void WhenButtonAttributeDetected(VisualElement root);
                    }
                }
            }

            #endif

            """;

            spc.AddSource($"ButtonDrawer_{safeName}.g.cs", drawerSourceCode);

            var whenNoButtonsSources = $$"""
            // <auto-generated/>

            #if UNITY_EDITOR

            #nullable enable

            using UnityEditor;
            using UnityEngine.UIElements;

            {{@namespace}}
            {
                {{accessibility}} sealed partial class {{safeName}}
                {
                    internal sealed partial class ButtonDrawer_{{safeName}}
                    {
                        private partial void WhenButtonAttributeDetected(VisualElement root)
                        {
                            var targetTyped = ({{type.ToDisplayString()}})target;
            
                            {{buttonsCode}}
                        }
                    }
                }
            }

            #endif

            """;

            spc.AddSource($"ButtonDrawer_{safeName}.buttons.g.cs", whenNoButtonsSources);
        }
    }

    private static string BuildButtonCode(IMethodSymbol? method)
    {
        if (method == null) return string.Empty;

        return $$"""
        root.Add(new Button({{BuildCall(method)}})
                        {
                            text = "{{GetLabel(method)}}"
                        });
        """;
    }

    private static string BuildCall(IMethodSymbol method)
    {
        var name = method.Name;

        return method.IsStatic
            ? $"() => {method.ContainingType.ToDisplayString()}.{name}()"
            : $"() => targetTyped.{name}()";
    }

    private static string GetLabel(IMethodSymbol method)
    {
        var attr = method.GetAttributes()
            .First(static candidate => candidate.AttributeClass!.ToDisplayString() == AttributeFullName);

        // ButtonAttribute(string label, string methodName) или (string methodName)
        if (attr.ConstructorArguments.Length == 2) return attr.ConstructorArguments[0].Value?.ToString() ?? method.Name;

        return method.Name;
    }

    private static class Using
    {
        internal static class System
        {
            internal const string Value = $"{nameof(System)}";

            internal static class CodeDom
            {
                internal const string Value = $"{System.Value}.{nameof(CodeDom)}";

                internal static class Compiler
                {
                    internal const string Value = $"{CodeDom.Value}.{nameof(Compiler)}";
                }
            }

            internal static class Diagnostics
            {
                internal const string Value = $"{System.Value}.{nameof(Diagnostics)}";

                internal static class CodeAnalysis
                {
                    internal const string Value = $"{Diagnostics.Value}.{nameof(CodeAnalysis)}";
                }
            }
        }

        internal static class Unity
        {
            internal static class Engine
            {
                internal const string Value = $"{nameof(Unity)}{nameof(Engine)}";

                internal static class UIElements
                {
                    internal const string Value = $"{Engine.Value}.{nameof(UIElements)}";
                }
            }

            internal static class Editor
            {
                internal const string Value = $"{nameof(Unity)}{nameof(Editor)}";
            }
        }
    }
}

file static class SyntaxFactoryExtensions
{
    internal static SyntaxTokenList AddIfPresent(this SyntaxTokenList list, SyntaxToken token)
    {
        if (token.IsKind(SyntaxKind.None)) return list;

        return list.Add(token);
    }
}

file static class Diagnostics
{
    internal static DiagnosticDescriptor MissingPartialDescriptor { get; } = new
    (
        id: "CA1812",
        title: "Missing partial modifier",
        messageFormat: "Type '{0}' is missing `partial` type modifier!",
        category: "Usage",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );
}
