using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static Microsoft.CodeAnalysis.CSharp.SyntaxKind;

namespace CustomAttributesEditorGenerator.Components;

using InspectorAttributes;

[SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
[SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
internal static class Using
{
    public static CompilationUnitSyntax AddUsings(this CompilationUnitSyntax compilation, params IReadOnlyCollection<string> usings)
    {
        var candidates = usings
            .Select(static @using => UsingDirective(ParseName(@using)))
            .ToArray();

        return compilation.AddUsings(candidates);
    }

    public static class System
    {
        public const string Value = $"{nameof(System)}";

        public static class CodeDom
        {
            public const string Value = $"{System.Value}.{nameof(CodeDom)}";

            public static class Compiler
            {
                public const string Value = $"{CodeDom.Value}.{nameof(Compiler)}";
            }
        }

        public static class Diagnostics
        {
            public const string Value = $"{System.Value}.{nameof(Diagnostics)}";

            public static class CodeAnalysis
            {
                public const string Value = $"{Diagnostics.Value}.{nameof(CodeAnalysis)}";
            }
        }
    }

    public static class Unity
    {
        public static class Engine
        {
            public const string Value = $"{nameof(Unity)}{nameof(Engine)}";

            public static class UIElements
            {
                public const string Value = $"{Engine.Value}.{nameof(UIElements)}";
            }
        }

        public static class Editor
        {
            public const string Value = $"{nameof(Unity)}{nameof(Editor)}";
        }
    }
}

internal static class Header
{
    public static CompilationUnitSyntax AddGenericHeader(this CompilationUnitSyntax compilation)
    {
        return compilation.WithLeadingTrivia(TriviaList(
            Comment("// <auto-generated/>"),
            Trivia(IfDirectiveTrivia(IdentifierName("UNITY_EDITOR"), isActive: true, branchTaken: true, conditionValue: true)),
            Trivia(NullableDirectiveTrivia(Token(EnableKeyword), isActive: true))));
    }

    public static CompilationUnitSyntax AddHeaderWithDefinitions(this CompilationUnitSyntax compilation, params ReadOnlySpan<string?> definitionKeys)
    {
        var triviaList = new List<SyntaxTrivia>
        {
            Comment("// <auto-generated/>"),
            Trivia(IfDirectiveTrivia(IdentifierName("UNITY_EDITOR"), isActive: true, branchTaken: true, conditionValue: true))
        };

        foreach (ref readonly var defineKey in definitionKeys)
        {
            if (defineKey is not null)
            {
                triviaList.Add(Trivia(DefineDirectiveTrivia(defineKey, isActive: true)));
            }
        }

        triviaList.Add(Trivia(NullableDirectiveTrivia(Token(EnableKeyword), isActive: true)));
        triviaList.Add(LineFeed);

        return compilation.WithLeadingTrivia(triviaList);
    }
}

internal static class Footer
{
    public static CompilationUnitSyntax AddGenericFooter(this CompilationUnitSyntax compilation)
    {
        return compilation.WithTrailingTrivia(TriviaList(
            Trivia(EndIfDirectiveTrivia(isActive: true)),
            CarriageReturn));
    }
}

internal static class Namespace
{
    public static CompilationUnitSyntax AddNamespace(this CompilationUnitSyntax compilation, NamespaceDeclarationSyntax @namespace)
    {
        return compilation.AddMembers(@namespace);
    }

    public static NamespaceDeclarationSyntax CreateNamespace(string name)
    {
        return NamespaceDeclaration(ParseName(name));
    }
}

internal static class Class
{
    public static NamespaceDeclarationSyntax AddClass(this NamespaceDeclarationSyntax @namespace, ClassDeclarationSyntax @class)
    {
        return @namespace.AddMembers(@class);
    }

    public static ClassDeclarationSyntax AddClass(this ClassDeclarationSyntax @class, ClassDeclarationSyntax subClass)
    {
        return @class.AddMembers(subClass);
    }

    public static ClassDeclarationSyntax CreateClass
    (
        string name,
        ReadOnlySpan<SyntaxKind> modifiers,
        ReadOnlySpan<string> baseTypes,
        ReadOnlySpan<(string, IReadOnlyCollection<object> Args)> attributes
    ) {
        var @class = ClassDeclaration(name)
            .AddModifiers(modifiers)
            .AddBaseTypes(baseTypes)
            .AddAttributes(attributes);

        return @class;
    }

    private static ClassDeclarationSyntax AddModifiers(this ClassDeclarationSyntax @class, ReadOnlySpan<SyntaxKind> modifiers)
    {
        if (modifiers.Length == 0) return @class;

        foreach (ref readonly var modifier in modifiers)
        {
            if (modifier is not None)
            {
                @class = @class.AddModifiers(Token(modifier));
            }
        }

        return @class;
    }

    private static ClassDeclarationSyntax AddAttributes(this ClassDeclarationSyntax @class, ReadOnlySpan<(string, IReadOnlyCollection<object> Args)> attributes)
    {
        if (attributes.Length == 0) return @class;

        var list = AttributeList();

        foreach (var (attribute, args) in attributes)
        {
            if (args.Count == 0)
            {
                list = list.AddAttributes(Attribute(IdentifierName(attribute)));
            }
            else
            {
                var income = SeparatedList<AttributeArgumentSyntax>()
                    .AddRange(args.Select(static income =>
                    {
                        if (income is string stringIncome)
                        {
                            return AttributeArgument(LiteralExpression(StringLiteralExpression, Literal(stringIncome)));
                        }
                        else if (income is TypeSyntax typeIncome)
                        {
                            return AttributeArgument(TypeOfExpression(typeIncome));
                        }

                        return null!;
                    }));

                list = list.AddAttributes(Attribute(IdentifierName(attribute),
                    AttributeArgumentList()
                        .WithArguments(income)));
            }
        }

        @class = @class.AddAttributeLists(list);

        return @class;
    }

    private static ClassDeclarationSyntax AddBaseTypes(this ClassDeclarationSyntax @class, ReadOnlySpan<string> baseTypes)
    {
        if (baseTypes.Length == 0) return @class;

        var list = new SeparatedSyntaxList<BaseTypeSyntax>();
        foreach (var type in baseTypes)
        {
            list = list.Add(SimpleBaseType(IdentifierName(type)));
        }

        return @class.WithBaseList(BaseList(list));
    }
}

internal static class Method
{
    public static ClassDeclarationSyntax AddMethod(this ClassDeclarationSyntax @class, MethodDeclarationSyntax method)
    {
        return @class.AddMembers(method);
    }

    public static MethodDeclarationSyntax CreateInspectorGUIMethod()
    {
        var method = MethodDeclaration(returnType: IdentifierName(nameof(UnityEngine.UIElements.VisualElement)),
            Identifier(nameof(UnityEditor.Editor.CreateInspectorGUI)))
                .WithModifiers(new SyntaxTokenList(Token(PublicKeyword), Token(OverrideKeyword)));

        StatementSyntax[] statements = [
            // var root = new VisualElement();
            LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("root"))
                    .WithInitializer(EqualsValueClause(ObjectCreationExpression(IdentifierName("VisualElement"))
                        .WithArgumentList(ArgumentList())))))),
            // var defaultRoot = new VisualElement();
            LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("defaultRoot"))
                    .WithInitializer(EqualsValueClause(ObjectCreationExpression(IdentifierName("VisualElement"))
                        .WithArgumentList(ArgumentList())))))),
            // var customRoot = new VisualElement();
            LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("customRoot"))
                    .WithInitializer(EqualsValueClause(ObjectCreationExpression(IdentifierName("VisualElement"))
                        .WithArgumentList(ArgumentList())))))),

            // root.Add(defaultRoot);
            ExpressionStatement(InvocationExpression(
                MemberAccessExpression(SimpleMemberAccessExpression, IdentifierName("root"), IdentifierName("Add")))
                    .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(IdentifierName("defaultRoot")))))),
            // root.Add(customRoot);
            ExpressionStatement(InvocationExpression(
                    MemberAccessExpression(SimpleMemberAccessExpression, IdentifierName("root"), IdentifierName("Add")))
                .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(IdentifierName("customRoot")))))),

            // UnityEditor.UIElements.InspectorElement.FillDefaultInspector(defaultRoot, serializedObject, this);
            ExpressionStatement(InvocationExpression(
                MemberAccessExpression(SimpleMemberAccessExpression,
                    IdentifierName($"{nameof(UnityEditor)}.{nameof(UnityEditor.UIElements)}.{nameof(UnityEditor.UIElements.InspectorElement)}"),
                    IdentifierName(nameof(UnityEditor.UIElements.InspectorElement.FillDefaultInspector))))
                    .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>([
                        Argument(IdentifierName("defaultRoot")),
                        Argument(IdentifierName(nameof(UnityEditor.Editor.serializedObject))),
                        Argument(ThisExpression())])))),

            // WhenButtonAttributeDetected(customRoot);
            ExpressionStatement(InvocationExpression(IdentifierName("WhenButtonAttributeDetected"))
                .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(IdentifierName("customRoot")))))),

            // ApplyCustomUIProcessing(ref defaultRoot, ref customRoot);
            ExpressionStatement(InvocationExpression(IdentifierName("ApplyCustomUIProcessing"))
                .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>([
                    Argument(IdentifierName("defaultRoot"))
                        .WithRefKindKeyword(Token(RefKeyword)),
                    Argument(IdentifierName("customRoot"))
                        .WithRefKindKeyword(Token(RefKeyword))])))),

            // return root;
            ReturnStatement(IdentifierName("root"))
        ];

        return method.WithBody(Block(statements));
    }

    public static MethodDeclarationSyntax CreateWhenButtonAttributeDetectedPartialMethod(string defineKey)
    {
        var attribute = Attribute(IdentifierName("Conditional"),
            AttributeArgumentList(
                SingletonSeparatedList(
                    AttributeArgument(LiteralExpression(StringLiteralExpression, Literal(defineKey))))));

        var method = MethodDeclaration(PredefinedType(Token(VoidKeyword)), Identifier("WhenButtonAttributeDetected"))
            .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(attribute))))
            .WithModifiers(new SyntaxTokenList(Token(PrivateKeyword), Token(PartialKeyword)))
                .WithParameterList(ParameterList(SingletonSeparatedList(
                    Parameter(Identifier("root"))
                        .WithType(IdentifierName(nameof(UnityEngine.UIElements.VisualElement))))))
                .WithSemicolonToken(Token(SemicolonToken));

        return method;
    }

    public static MethodDeclarationSyntax CreateWhenButtonAttributeDetectedMethod(string castType, IEnumerable<IMethodSymbol?> methods)
    {
        var statements = new SyntaxList<StatementSyntax>();
        statements = statements.Add
        (

            LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
                .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("targetTyped"))
                    .WithInitializer(EqualsValueClause(CastExpression(IdentifierName(castType), IdentifierName("target")))))))

        );

        foreach (var method in methods.Where(static symbol => symbol is not null).Cast<IMethodSymbol>())
        {
            var label = GetLabel(method);
            var callMethod = method.Name;

            statements = statements.Add
            (

                ExpressionStatement(InvocationExpression(MemberAccessExpression(SimpleMemberAccessExpression, IdentifierName("root"), IdentifierName("Add")))
                    .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(
                        ObjectCreationExpression(IdentifierName("Button"))
                            .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(
                                ParenthesizedLambdaExpression()
                                    .WithParameterList(ParameterList())
                                    .WithExpressionBody(InvocationExpression(MemberAccessExpression(SimpleMemberAccessExpression, IdentifierName("targetTyped"), IdentifierName(callMethod))))))))
                            .WithInitializer(InitializerExpression(ObjectInitializerExpression,
                                SeparatedList<ExpressionSyntax>()
                                    .Add(AssignmentExpression(
                                        SimpleAssignmentExpression,
                                        IdentifierName("text"),
                                        LiteralExpression(StringLiteralExpression, Literal(label)))))))))))

            );
        }

        var declaration = MethodDeclaration(PredefinedType(Token(VoidKeyword)), Identifier("WhenButtonAttributeDetected"))
            .WithModifiers(new SyntaxTokenList(Token(PrivateKeyword), Token(PartialKeyword)))
            .WithParameterList(ParameterList(SingletonSeparatedList(Parameter(Identifier("root"))
                .WithType(IdentifierName(nameof(UnityEngine.UIElements.VisualElement))))));

        return statements.Count == 1
            ? declaration
            : declaration.WithBody(Block(statements));

        static string GetLabel(IMethodSymbol method)
        {
            var attribute = method.GetAttributes()
                .First(static candidate => candidate.AttributeClass!.Name == nameof(ButtonAttribute));

            if (attribute.ConstructorArguments.Length == 1) return attribute.ConstructorArguments[0].Value as string ?? method.Name;

            return method.Name;
        }
    }

    public static MethodDeclarationSyntax CreateWhenCustomAttributeDetectedPartialMethod(string defineKey)
    {
        var attribute = Attribute(IdentifierName("Conditional"),
            AttributeArgumentList(
                SingletonSeparatedList(
                    AttributeArgument(LiteralExpression(StringLiteralExpression, Literal(defineKey))))));

        var method = MethodDeclaration(PredefinedType(Token(VoidKeyword)), Identifier("ApplyCustomUIProcessing"))
            .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(attribute))))
            .WithModifiers(new SyntaxTokenList(Token(PrivateKeyword), Token(PartialKeyword)))
            .WithParameterList(ParameterList(SeparatedList<ParameterSyntax>()
                .Add(Parameter(Identifier("defaultRoot"))
                    .WithType(IdentifierName(nameof(UnityEngine.UIElements.VisualElement)))
                    .WithModifiers(SyntaxTokenList.Create(Token(RefKeyword))))
                .Add(Parameter(Identifier("customRoot"))
                    .WithType(IdentifierName(nameof(UnityEngine.UIElements.VisualElement)))
                    .WithModifiers(SyntaxTokenList.Create(Token(RefKeyword))))
            )).WithSemicolonToken(Token(SemicolonToken));

        return method;
    }

    public static MethodDeclarationSyntax CreateWhenCustomAttributeMissedPartialMethod(string defineKey)
    {
        var attribute = Attribute(IdentifierName("Conditional"),
            AttributeArgumentList(
                SingletonSeparatedList(
                    AttributeArgument(LiteralExpression(StringLiteralExpression, Literal(defineKey))))));

        StatementSyntax[] statements = [
            ReturnStatement()
                .WithLeadingTrivia(Comment("// Custom UI Processing will not be applied ..."))
        ];

        return MethodDeclaration(PredefinedType(Token(VoidKeyword)), Identifier("ApplyCustomUIProcessing"))
            .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(attribute))))
            .WithModifiers(new SyntaxTokenList(Token(PrivateKeyword)))
            .WithParameterList(ParameterList(SeparatedList<ParameterSyntax>()
                .Add(Parameter(Identifier("defaultRoot"))
                    .WithType(IdentifierName(nameof(UnityEngine.UIElements.VisualElement)))
                    .WithModifiers(SyntaxTokenList.Create(Token(RefKeyword))))
                .Add(Parameter(Identifier("customRoot"))
                    .WithType(IdentifierName(nameof(UnityEngine.UIElements.VisualElement)))
                    .WithModifiers(SyntaxTokenList.Create(Token(RefKeyword))))
            )).WithBody(Block(statements));
    }
}
